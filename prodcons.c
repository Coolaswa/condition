/* 
 * Operating Systems   (2INCO)   Practical Assignment
 * Condition Variables Application
 *
 * Michiel Favier (0951737)
 * Diederik de Wit (0829667)
 *
 * Grading:
 * Students who hand in clean code that fully satisfies the minimum requirements will get an 8. 
 * "Extra" steps can lead to higher marks because we want students to take the initiative. 
 * Extra steps can be, for example, in the form of measurements added to your code, a formal 
 * analysis of deadlock freeness etc.
 */
 
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <pthread.h>
#include <time.h>
#include <unistd.h>

#include "prodcons.h"

/* buffer[]
 * circular buffer that holds the items generated by the producer and
 * which have to be retrieved by consumers
 */
static ITEM   buffer [BUFFER_SIZE];
pthread_mutex_t bufferMutex = PTHREAD_MUTEX_INITIALIZER;
static pthread_cond_t prodCondition = PTHREAD_COND_INITIALIZER;
static pthread_cond_t conCondition[NROF_CONSUMERS];
static pthread_cond_t readyCondition;
pthread_cond_t placeHolder = PTHREAD_COND_INITIALIZER;

static void rsleep (int t);

/* producer thread */
static void * producer (void * arg)
{
    ITEM    item;   // a produced item
    int itemsProduced = 1; //The item which is going to be produced next.
    bool bufferEmpty = true;
	
    while (itemsProduced < NROF_ITEMS || !bufferEmpty)
    {
        rsleep (PRODUCER_SLEEP_FACTOR);
        pthread_mutex_lock(&bufferMutex);
        if(buffer[BUFFER_SIZE - 1] == 0){
        	bufferEmpty = true;
        } else {
        	bufferEmpty = false;
        }
	    //If the buffer is empty and not all items have been produced yet, fill the buffer.
       	if(bufferEmpty && itemsProduced < NROF_ITEMS) {

            printf("Producer waiting for condition\n");
            pthread_cond_wait(&prodCondition, &bufferMutex);
            printf("Producer started to fill buffer\n");
            //fill buffer
       		int i;
       		for(i = 0; i < BUFFER_SIZE; i++){
            	unsigned short int randomDestination = (rand() % NROF_CONSUMERS) + 1;
            	unsigned short int itemShift = (unsigned short int)itemsProduced << NROF_BITS_DEST;
            	item = itemShift | randomDestination;
            	itemsProduced++;
            	buffer[i] = item;
            	printf("%04x\n", item); // write info to stdout
       		}
       		bufferEmpty = false;
            //end buffer
       	} else {
       		int i;
       		unsigned short int dest;
       		bool first = true;
			for(i = 0; i < BUFFER_SIZE; i++){
				if (buffer[i] != 0) {
					ITEM locItem = buffer[i];
					if(!first){
						printf("Waiting on previous thread to be ready\n");
						pthread_cond_wait(&readyCondition, &bufferMutex);
					}
					first = false;
					dest = locItem & ((unsigned short int)~0 >> (16-NROF_BITS_DEST));
					pthread_cond_signal(&conCondition[dest]); //TODO: The producer might signal before the consumers are ready
					printf("Just signaled consumer %d\n", dest);
					pthread_cond_wait(&prodCondition, &bufferMutex);
					break;
				}
			}
       	}
       	pthread_mutex_unlock(&bufferMutex);
    }
    printf("Producer done\n");
    // TODO: 
    // * inform consumers that we're ready
    return(NULL);
}

/* consumer thread */
static void * consumer (void * arg)
{
	int itemsConsumed = 1;
    ITEM    item;   // a consumed item
    int     id = *((int*)arg);     // identifier of this consumer (value 0..NROF_CONSUMERS-1)
    printf("My id is: %d\n", id);
    
    while (itemsConsumed < NROF_ITEMS)
    {
        rsleep (100 * NROF_CONSUMERS);
        
	    //TODO: Please check this new consumer loop
        int i;
        pthread_mutex_lock(&bufferMutex);
       	printf("Consumer %d achieved successful lock and is waiting for the condition\n", id);
       	pthread_cond_signal(&readyCondition);
       	printf("Signaled the producer we're ready\n");
    	pthread_cond_wait(&conCondition[id], &bufferMutex);
	    for (i = 0; i <= BUFFER_SIZE; i++)
	    {
		   	if (buffer[i] != 0) //We could include some check to make sure the consumer takes the right item.
		   	{
		    	printf("Consumer %d taking one item from the buffer\n", id);
		    	item = buffer[i];
		    	buffer[i] = 0;
		    	itemsConsumed++;
		    	printf("%*s    C%d:%04x\n", 7*id, "", id, item); // write info to stdout (with indentation)
		    	pthread_cond_signal(&prodCondition);
		    	break;
		   	}
		   	else if (i == BUFFER_SIZE && buffer[BUFFER_SIZE] == 0)
		   	{
		    	pthread_cond_signal(&prodCondition);
		   	}
		   	else //This else statement will be entered every time that (buffer[i]==0) && (i != BUFFER_SIZE)
		   	{
		    	//Just fluff for now
		   	}
	    }
	    pthread_mutex_unlock(&bufferMutex);
    }
    printf("Consumer %d done\n", id);
    return(NULL);
}

int main (void)
{
    // TODO: 
    // * startup the producer thread and the consumer threads
    // * wait until all threads are finished  
    // (see assignment Threaded Application how to create threads and how to wait for them)
	int i;
	for(i = 0; i < NROF_CONSUMERS; i++){
		conCondition[i] = placeHolder;
	}
	pthread_t producer_id, consumer_id[NROF_CONSUMERS];
	int newThread = pthread_create(&producer_id, NULL, producer, NULL);
	if(newThread == -1){
		perror("Creating the producer thread failed");
		exit(1);
	}
	int con_id[NROF_CONSUMERS];
	printf("Producer created\n");
	for(i = 1; i <= NROF_CONSUMERS; i++ ){
		con_id[i] = i;
		newThread = pthread_create(&consumer_id[i], NULL, consumer, &con_id[i]);
		if(newThread == -1){
			perror("Creating a consumer thread failed");
			exit(1);
		}
		printf("Consumer %d created\n", i);
	}
	sleep(2);
	pthread_cond_signal(&prodCondition);
	pthread_join(producer_id, NULL);
	for(i = 1; i <= NROF_CONSUMERS; i++){
		pthread_join(consumer_id[i], NULL);
	}
    return (0);
}

/*
 * rsleep(int t)
 *
 * The calling thread will be suspended for a random amount of time between 0 and t microseconds
 * At the first call, the random generator is seeded with the current time
 */
static void rsleep (int t)
{
    static bool first_call = true;
    
    if (first_call == true)
    {
        srandom (time (NULL) % getpid ());
        first_call = false;
    }
    usleep (random() % t);
}

